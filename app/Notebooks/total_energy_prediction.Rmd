---
title: "Prediction of Total Electrical Net Generation From Coal"
author: "John Grando"
date: "October 19, 2020"
output: 
  html_document:
    css: "CSS/main.css"

---

<strong>[Home Page](https://john-grando.github.io/)</strong>

In this analysis, we take a look at the aggregated U.S. net electrical generation, and how that power is produced.  The preliminary steps will show the breakdown of various fuel sources and then we will move into a quick forecast of coal consumption within the next few years.

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  dev.args=list(bg = 'transparent'),
  fig.align='center')
```

```{r warning=FALSE}
suppressWarnings(suppressMessages(library(tidyverse)))
suppressWarnings(suppressMessages(library(RColorBrewer)))
suppressWarnings(suppressMessages(library(kableExtra)))
suppressWarnings(suppressMessages(library(gridExtra)))
suppressWarnings(suppressMessages(library(forecast)))
suppressWarnings(suppressMessages(library(ggplot2)))
suppressWarnings(suppressMessages(library(sparklyr)))
suppressWarnings(suppressMessages(library(dplyr)))
suppressWarnings(suppressMessages(library(tidyr)))
```

First, we will load cleansed data from a previous ETL phase that was stored in hadoop.  This information is provided from the bulk downloaded files available at the [U.S. Energy Information Administration](https://www.eia.gov/opendata/bulkfiles.php).

```{r}
sc <- sparklyr::spark_connect(
  master = 'local[2]', 
  spark_home = Sys.getenv("SPARK_HOME"))
total_energy_df <- sparklyr::spark_read_parquet(
  sc = sc, 
  name = 'total_energy_df', 
  path = "hdfs://localhost:9000/Processed/TotalEnergyDF")
total_energy_df <- select(
    total_energy_df, 
    "date", 
    "name", 
    "value", 
    "units") %>% 
  mutate(
    date = as.Date(date),
    value = as.numeric(value)) %>% 
  arrange(date)
```

We will cut off any measurements older than 1990, as many records are missing for certain categories, and the does not appear to be useful in its current form.  After a quick check, we see that there are no null values in the fields we selected.

```{r}
electricity_net_generation_df <- total_energy_df %>% 
  dplyr::filter(date >= as.Date("1990-01-01") & date < as.Date("2020-01-01")) %>% 
  dplyr::filter(name %rlike% "(Electricity Net Generation From.*All Sectors$)")
```

```{r eval=FALSE}
electricity_net_generation_df %>% 
  dplyr::filter(is.na(value) | value == '') %>% 
  dplyr::count(name = "null fields") %>% 
  kable('html') %>% 
  kable_styling(
    bootstrap_options = 'striped',
    full_width = FALSE,
    position = "center",
    font_size = 20)
```


```{r}
date_limit_df <- electricity_net_generation_df %>% 
  group_by() %>% 
  dplyr::summarize(
    min_date = min(date), 
    max_date = max(date)) %>% 
  sparklyr::collect()
```


```{r}
electricity_net_generation_pivot_df <- electricity_net_generation_df %>% 
  dplyr::mutate(
    name = regexp_replace(name, '^Electricity Net Generation From (.*), All Sectors$', 'eng_$1'),
    name = tolower(name)
  ) %>% 
  mutate(
    name = regexp_replace(name, ' ', '_')
  ) %>% 
  sdf_pivot(
    formula = date ~ name, 
    fun.aggregate = list(value = "mean"))

```

And now, we can take a first look at the net generation by fuel type.  It's immediately obvious that coal, natural gas, and nuclear power make up the major portion of consumed fuels, so we will group all others into a single category for simplicity.

```{r fig.width=12}
color_values <- colorspace::diverge_hcl(n = 12, c = 100, l = c(20,90), power = 1)

electricity_net_generation_pivot_melted_df <- electricity_net_generation_pivot_df %>% 
    collect() %>% 
    gather(key = "id", value = 'val', -c(date))

plot_theme <- theme(plot.title = element_text(hjust = 0.5, size = 25),
        plot.subtitle = element_text(hjust = 0.5, size = 14),
        strip.text = element_text(size = 20),
        plot.background = element_rect(fill = "lightgrey"), 
        panel.background = element_rect(fill = "white"), 
        panel.grid.major.x = element_line(color = "lightgrey"), 
        panel.grid.major.y = element_line(color = "lightgrey"), 
        axis.text = element_text(size=14, color = "grey1"), 
        axis.title = element_text(size=16, color = "grey1"))

ggplot(
  data = electricity_net_generation_pivot_melted_df, 
  mapping = aes(x = date, y = val, color = id)) +
  geom_line() +
  scale_color_manual(values = color_values) +
  labs(x = "Date", y = "Million kWh") +
  ggtitle("Electricity Net Generation") +
  plot_theme
```

```{r}
electricity_net_generation_pivot_reduced_df <- electricity_net_generation_df %>% 
  filter(date > as.Date('2010-01-01')) %>% 
  dplyr::mutate(
    name = regexp_replace(name, '^Electricity Net Generation From (.*), All Sectors$', 'eng_$1'),
    name = tolower(name)) %>% 
  mutate(
    name = regexp_replace(name, ' ', '_')
  ) %>% 
  mutate(
    name = ifelse(
      name %in% c(
        "eng_coal", 
        "eng_natural_gas", 
        "eng_nuclear_electric_power"), 
      name, 
      "eng_other")
  ) %>% 
  sdf_pivot(
    formula = date ~ name, 
    fun.aggregate = list(value = "mean"))

date_limit_reduced_df <- electricity_net_generation_pivot_reduced_df %>% 
  group_by() %>% 
  dplyr::summarize(
    min_date = min(date), 
    max_date = max(date)) %>% 
  sparklyr::collect()
```

Now we can see that in general the generation from coal has been on a slow decline with natural gas doing the opposite and nuclear electric power holding at a steady output.

```{r fig.width=12}
electricity_net_generation_pivot_melted_df <- electricity_net_generation_pivot_reduced_df %>% 
    collect() %>% 
    gather(key = "id", value = 'val', -c(date))
ggplot(
  data = electricity_net_generation_pivot_melted_df, 
  mapping = aes(x = date, y = val, color = id)) +
  geom_line() +
  scale_color_manual(values = color_values) +
  labs(x = "Date", y = "Million kWh") +
  ggtitle("Electricity Net Generation - Reduced Categories") +
  plot_theme
```

So, let's see if we can predict the future of coal consumption.  Note, this is very much a simple analysis and there are many factors that contribute to the various fuels usages, inclding political and economical.  For this analysis, we will try to fit the time series to an ARIMA model, given how flexible it can be in hyperparamter testing.

```{r}
eng_coal_ts <- ts(
  data = electricity_net_generation_pivot_reduced_df %>%  
    arrange(date) %>% 
    select("eng_coal") %>% 
    collect() %>% 
    pull("eng_coal"), 
  start = c(
    as.numeric(format(date_limit_reduced_df["min_date"][[1]], "%Y")), 
    as.numeric(format(date_limit_reduced_df["min_date"][[1]], "%m"))),
  end = c(
    as.numeric(format(date_limit_reduced_df["max_date"][[1]], "%Y")), 
    as.numeric(format(date_limit_reduced_df["max_date"][[1]], "%m"))),
  frequency = 12)
```

From the seasonal plot wee see a rather consistent patter of peaks and valleys based on the month. The ACF plot is decaying, indicating that an arima differencing model may be appropriate.  The PACF plot show spikes at periodic lags, suggesting that differencing and/or moving average models may be appropriate.

```{r fig.width=12}
ggseasonplot(eng_coal_ts, polar=TRUE) +
  scale_color_manual(values=color_values) +
  ggtitle("Seasonal Coal Generation") +
  plot_theme
```

```{r fig.width=12}
autoplot(eng_coal_ts, series='original') + 
  labs(x = "Year", y = "Million kWh") +
  ggtitle("Electricity Net Generation From Coal") +
  scale_color_manual(values=color_values) +
  plot_theme
```

```{r fig.width=12}
acf_plot <- ggAcf(eng_coal_ts) + 
  plot_theme +
  ggtitle("ACF")
pacf_plot <- ggPacf(eng_coal_ts) +
  plot_theme +
  ggtitle("PACF")
grid.arrange(acf_plot, pacf_plot, ncol=2)
```

In order to try and create the most useful model, we will try to use the natural gas and nuclear power generation values as predictors for the ARIMA model as well.  As a first step, we will evaluate what happens when we let `auto.arima` pick the model for us.  We will hold out the last 12 predictions for later testing.

Surprisingly, the non-seasonal differencing value was selected to be zero, which may be due to the regressors.  However, we do see that the box test has given us promising results that the residuals are not correlated.  Also, due tto the COVID pandemic, we will leave out the 2020 data from training and testing.

```{r}

  
```


```{r}
prediction_length <- 48
eng_coal_train_ts <- subset(eng_coal_ts, start = 1, end = length(eng_coal_ts) - prediction_length)
eng_coal_test_ts <- subset(eng_coal_ts, start = length(eng_coal_ts) - prediction_length)

# Previous attempts used the raw net generation values from other sources.
# Howver, using the cumulative means provides a simpler comparison and smoother
#predictor for fitting
#p_xreg <- matrix(
#  c(
#    electricity_net_generation_pivot_reduced_df %>% select('eng_natural_gas') %>% pull(),
#    electricity_net_generation_pivot_reduced_df %>% select('eng_nuclear_electric_power') %>% pull()),
#  ncol=2, 
#  byrow = FALSE
#)

#using rolling median
p_rollmean_df <- electricity_net_generation_pivot_df %>% 
  arrange(date) %>% 
  select(date, eng_natural_gas, eng_nuclear_electric_power) %>% 
  collect() %>% 
  mutate(
    eng_natural_gas = zoo::rollmedianr(lag(eng_natural_gas), k = 13, fill = NA),
    eng_nuclear_electric_power = zoo::rollmeanr(lag(eng_nuclear_electric_power), k = 13, fill = NA)
  ) %>% 
  filter(date > as.Date('2010-01-01')) %>% 
  select(-date)

p_xreg <- matrix(
  c(
    p_rollmean_df %>% select('eng_natural_gas') %>% pull(),
    p_rollmean_df %>% select('eng_nuclear_electric_power') %>% pull()),
  ncol=2, 
  byrow = FALSE
)

p_xreg_train <- matrix(p_xreg[1:length(eng_coal_train_ts),], ncol = dim(p_rollmean_df)[2])
p_xreg_test <- matrix(p_xreg[length(eng_coal_train_ts):length(eng_coal_ts),], ncol = dim(p_rollmean_df)[2])

#export for hyperparameter testing
save(eng_coal_train_ts, p_xreg_train, file = paste("../RFiles/Data/total_energy_coal_data.RData", sep="/"))

auto_fit <- auto.arima(eng_coal_train_ts, xreg = p_xreg_train)

checkresiduals(auto_fit)
summary(auto_fit)
```

Now, let's give our own guess a shot by using the [time series cross validation ](https://otexts.com/fpp2/accuracy.html) (tsCV) from the [forecast](https://github.com/robjhyndman/forecast) package.  Note, I had to make a series of edits to make this function operat when provided with the `xreg` option.  Notes on these edits can be found [here](https://github.com/john-grando/eia-data-analysis/blob/master/app/Notebooks/tsCV_analysis.md).

The results of the hyperparameter training did return favorable models for non-seasonal differencing models, so we will include that here

```{r}
hyper_fit <- Arima(
  eng_coal_train_ts, 
  order=c(1,0,0),
  seasonal=c(0,1,2),
  lambda = NULL,
  include.drift = TRUE,
  xreg=p_xreg_train)

checkresiduals(hyper_fit)
summary(hyper_fit)
```

Now we can test our models against each other as well as a few other prediction methods for comparison.  Specifically, we will add a seasonal naive predictor and an `auto.arima` model using no predictors

```{r}
auto_simple_fit <- auto.arima(eng_coal_train_ts)
checkresiduals(auto_simple_fit)
summary(auto_simple_fit)
```


```{r}

hyper_fit_df <- hyper_fit %>% 
  forecast(h = length(eng_coal_test_ts), xreg=p_xreg_test) %>% 
  accuracy(eng_coal_test_ts) %>% 
  data.frame() %>%  
  tibble::rownames_to_column(var = "model") %>% 
  mutate(model = paste("Hyper",model))
auto_fit_df <- auto_fit %>% 
  forecast(h = length(eng_coal_test_ts), xreg=p_xreg_test) %>% 
  accuracy(eng_coal_test_ts) %>% 
  data.frame() %>%  
  tibble::rownames_to_column(var = "model") %>% 
  mutate(model = paste("Auto",model))
auto_simple_fit_df <- auto_simple_fit %>% 
  forecast(h = length(eng_coal_test_ts)) %>% 
  accuracy(eng_coal_test_ts) %>% 
  data.frame() %>%  
  tibble::rownames_to_column(var = "model") %>% 
  mutate(model = paste("Auto Simple",model))
snaive_fit_df <- snaive(y = eng_coal_train_ts, h = length(eng_coal_test_ts)) %>% 
  accuracy(eng_coal_test_ts)  %>% 
  data.frame() %>%  
  tibble::rownames_to_column(var = "model") %>% 
  mutate(model = paste("Seasonal Naive",model))


hyper_fit_df %>% rbind(
  auto_fit_df,
  auto_simple_fit_df,
  snaive_fit_df
) %>% 
  filter(grepl('test', model, ignore.case = TRUE)) %>% 
  arrange(RMSE)
```



And now we can plot our predictions

```{r fig.width=12, warning=FALSE, message=FALSE}
#Adjust future predictors

auto_simple_forecast <- forecast(
    auto_simple_fit,
    h = prediction_length)

auto_forecast <- forecast(
    auto_fit,
    h = prediction_length, 
    xreg=p_xreg_test)

hyper_forecast <- forecast(
  hyper_fit,
  h = prediction_length, 
  xreg=p_xreg_test
)

autoplot(auto_simple_forecast) +
  autolayer(
    auto_simple_forecast,
    series = "Prediction",
    PI = FALSE) +
  autolayer(
    ts(
      c(p_xreg[,1]),
      start = c(
    as.numeric(format(date_limit_reduced_df["min_date"][[1]], "%Y")), 
    as.numeric(format(date_limit_reduced_df["min_date"][[1]], "%m"))),
      frequency = 12),
    series = 'natural gas') +
  autolayer(
    ts(
      c(p_xreg[,2]),
      start = c(
    as.numeric(format(date_limit_reduced_df["min_date"][[1]], "%Y")), 
    as.numeric(format(date_limit_reduced_df["min_date"][[1]], "%m"))),
      frequency = 12),
    series = 'nuclear') +
  autolayer(
    eng_coal_test_ts,
    series = "actual coal"
  ) + 
  autolayer(
    snaive(y = eng_coal_train_ts, length(eng_coal_test_ts)),
    PI = FALSE,
    series = "naive") +
  labs(x="Date", y="Million kWh") +
  scale_x_continuous(
    labels=function(x){as.integer(x)},
    limits=c(
      as.numeric(format(date_limit_reduced_df["max_date"][[1]], "%Y"))-8, 
      as.numeric(format(date_limit_reduced_df["max_date"][[1]], "%Y"))+1),
    breaks = seq(
      as.numeric(format(date_limit_reduced_df["max_date"][[1]], "%Y"))-8, 
      as.numeric(format(date_limit_reduced_df["max_date"][[1]], "%Y"))+1, 
      1)) +
  ggtitle(
    'Auto Arima Model - No Predictors', 
    subtitle = as.character(auto_simple_fit)) +
  plot_theme



autoplot(auto_forecast) +
  autolayer(
    auto_forecast,
    series = "Prediction",
    PI = FALSE) +
  autolayer(
    ts(
      c(p_xreg[,1]),
      start = c(
    as.numeric(format(date_limit_reduced_df["min_date"][[1]], "%Y")), 
    as.numeric(format(date_limit_reduced_df["min_date"][[1]], "%m"))),
      frequency = 12),
    series = 'natural gas') +
  autolayer(
    ts(
      c(p_xreg[,2]),
      start = c(
    as.numeric(format(date_limit_reduced_df["min_date"][[1]], "%Y")), 
    as.numeric(format(date_limit_reduced_df["min_date"][[1]], "%m"))),
      frequency = 12),
    series = 'nuclear') +
  autolayer(
    eng_coal_test_ts,
    series = "actual coal"
  ) + 
  autolayer(
    snaive(y = eng_coal_train_ts, length(eng_coal_test_ts)),
    PI = FALSE,
    series = "naive") +
  labs(x="Date", y="Million kWh") +
  scale_x_continuous(
    labels=function(x){as.integer(x)},
    limits=c(
      as.numeric(format(date_limit_reduced_df["max_date"][[1]], "%Y"))-8, 
      as.numeric(format(date_limit_reduced_df["max_date"][[1]], "%Y"))+1),
    breaks = seq(
      as.numeric(format(date_limit_reduced_df["max_date"][[1]], "%Y"))-8, 
      as.numeric(format(date_limit_reduced_df["max_date"][[1]], "%Y"))+1, 
      1)) +
  ggtitle(
    'Auto Arima Model', 
    subtitle = as.character(auto_fit)) +
  plot_theme

autoplot(hyper_forecast) +
  autolayer(
    hyper_forecast,
    series = "Prediction",
    PI = FALSE) +
  autolayer(
    ts(
      c(p_xreg[,1]),
      start = c(
    as.numeric(format(date_limit_reduced_df["min_date"][[1]], "%Y")), 
    as.numeric(format(date_limit_reduced_df["min_date"][[1]], "%m"))),
      frequency = 12),
    series = 'natural gas') +
  autolayer(
    ts(
      c(p_xreg[,2]),
      start = c(
    as.numeric(format(date_limit_reduced_df["min_date"][[1]], "%Y")), 
    as.numeric(format(date_limit_reduced_df["min_date"][[1]], "%m"))),
      frequency = 12),
    series = 'nuclear') +
  autolayer(
    eng_coal_test_ts,
    series = "actual coal"
  ) + 
  autolayer(
    snaive(y = eng_coal_train_ts, length(eng_coal_test_ts)),
    PI = FALSE,
    series = "naive") +
  labs(x="Date", y="Million kWh") +
  scale_x_continuous(
    labels=function(x){as.integer(x)},
    limits=c(
      as.numeric(format(date_limit_reduced_df["max_date"][[1]], "%Y"))-8, 
      as.numeric(format(date_limit_reduced_df["max_date"][[1]], "%Y"))+1),
    breaks = seq(
      as.numeric(format(date_limit_reduced_df["max_date"][[1]], "%Y"))-8, 
      as.numeric(format(date_limit_reduced_df["max_date"][[1]], "%Y"))+1, 
      1)) +
  ggtitle(
    'Hyperparameter Model', 
    subtitle = as.character(hyper_fit)) +
  plot_theme
```

```{r eval=FALSE}

amplifier <- 1
n_amplifier <- 1

tst <- tail(
  electricity_net_generation_pivot_reduced_df %>% select('eng_natural_gas') %>% pull(), prediction_length)
new_tst <- tst * tst[1] / tail(tst,1) * seq(from = 1, to = amplifier, length.out = prediction_length)
new_n_tst <- tail(
  electricity_net_generation_pivot_reduced_df %>% 
    select('eng_nuclear_electric_power') %>% 
    pull(), 
  prediction_length) * seq(from = 1, to = n_amplifier, length.out = prediction_length)

new_p_xreg <- matrix(
  c(
    new_tst,
    new_n_tst),
  ncol=2, 
  byrow = FALSE
)


#temporary save of plotting objects
  autolayer(
    ts(
      c(electricity_net_generation_pivot_reduced_df %>% select('eng_natural_gas') %>% pull()),
      start = c(
    as.numeric(format(date_limit_reduced_df["min_date"][[1]], "%Y")), 
    as.numeric(format(date_limit_reduced_df["min_date"][[1]], "%m"))),
      frequency = 12),
    series = 'natural gas') +
  autolayer(
    ts(
      new_tst,
      start = c(
    as.numeric(format(date_limit_reduced_df["max_date"][[1]], "%Y")), 
    as.numeric(format(date_limit_reduced_df["max_date"][[1]], "%m"))),
      frequency = 12),
    series = 'natural gas prediction'
  ) +
  autolayer(
    ts(
      c(electricity_net_generation_pivot_reduced_df %>% select('eng_nuclear_electric_power') %>% pull()),
      start = c(
    as.numeric(format(date_limit_reduced_df["min_date"][[1]], "%Y")), 
    as.numeric(format(date_limit_reduced_df["min_date"][[1]], "%m"))),
      frequency = 12),
    series = 'nuclear') +
  autolayer(
    ts(
      new_n_tst,
      start = c(
    as.numeric(format(date_limit_reduced_df["max_date"][[1]], "%Y")), 
    as.numeric(format(date_limit_reduced_df["max_date"][[1]], "%m"))),
      frequency = 12),
    series = 'nuclear prediction'
  ) +
  coord_cartesian(xlim=c(2010,2025), ylim = c(0,2.5e+05)) +
  scale_color_manual(values=color_values) +
  labs(x = "Date", y = "Million kWh") +
  ggtitle(
    as.character(auto_fit), 
    subtitle = paste("\nAmplification (NG): ", amplifier, ", Amplification (Nuclear): ", n_amplifier)) +
  plot_theme
```

